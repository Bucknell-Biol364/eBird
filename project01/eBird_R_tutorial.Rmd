---
title: "Project 1 - eBird Data"
author: "Riley McDonnell and Savannah Weaver"
date: "2/7/2020"
output: github_document
---

```{r setup, include=FALSE}
# initialize the document
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, include=FALSE}
# download the necessary packages for analyses
if (!require("UsingR")) install.packages("UsingR"); library(UsingR)
if (!require("tidyverse")) install.packages("tidyverse"); library(tidyverse)
if (!require("cowplot")) install.packages("cowplot"); library(cowplot)
if (!require("ggplot2")) install.packages("ggplot2"); library(ggplot2)
if (!require("dplyr")) install.packages(("dplyr")); library(dplyr)
```

# Introduction

Welcome to R/Rstudio, Ornithology students! R is a computer language that helps scientists (like you!) run statistical tests and create stunning graphs. Rstudio is an interface of R that makes it easier to understand your code and see its outputs. 

The bottom-right panel can be used to find files, see the graphs you make, and get help on code functions. The top-right panel is where you can view any saved variables. THIS panel in the top-left is where we will be reading, writing, and running code. The bottom-left panel below more or less prints what we do in this panel, so you can ignore it for now.

This file is an Rmd file, which lets us put plain text and code side-by-side. We won't discuss Rmd formatting for now... the important parts are the code chunks, which look like this:

```{r}
# code
print("Code!")
```

The top and bottom lines tell R that's the beginning and end of the code chunk. The middle is where we will be coding soon! Right now we just have two example lines of code. The first line starts with a #, which means it's a comment. This will not do anything, but is helpful to keep track of what code does line-by-line. If we were using an R-script file rather than Rmd, any non-code text would have to be "commented-out." The next line simply tells R to print a string of characters that we tell it to. Click the green "play" button at the top-right corner of the code to chunk to run this code.

Not too scary, right?! You can see the output of your code right below the code chunk. This is how we will run and see the output of our coding for the rest of the tutorial.

Don't worry if this is overwhelming right now! Slowly through this tutorial you will come to understand each of these panels and the code you can put together to analyze and visualize your data! And of course, don't be afraid to ask your instructor for help and/or clarification.

Happy Coding!

# Our Data

In Ornithology, you've been using eBird to submit your sightings. But where does that data go? Scienists and non-scientists alike can get access to it to analyze trends, and many scientific papers have been published using eBird data. Anyone can request it online (eBird Basic Dataset. Version: EBD_relDec-2019. Cornell Lab of Ornithology, Ithaca, New York. Dec 2019.). 

For our tutorial, we will use eBird's citizen science observations of the Black-capped Chickadee (*Poecile atricapillus*) and Northern Cardinal (*Cardinalis cardinalis*). *Note that each of these original eBird datasets are very large, so we only read in the first 1000 rows of each, then saved them both together as a new csv for use in this tutorial. Otherwise, it would take way too long to load in.*

We don't want to run this first code chunk, so it is all commented-out, but please read it to understand how we read-in and subsetted the data. We also recommend commenting your code like this so it's clear to you and other people what everything does!

```{r}
# the eBird data comes as txt files, which can be handled by read.delim() function
# read.delim() lets us tell R things about the data
# we say that there is a header row, and that it's tab-delimited ("/t")
# we only read in 1000 rows for each dataset

# read in whole dataset for the black-capped chickadee
# and save read-in data as a dataframe called bcc
#bcc<- read.delim("./ebd_black_capped_chickadee/bcc_data.txt", header = TRUE, sep = "\t", dec = ".", nrows=1000)

# read in the whole dataset for the northern cardinal
# and save read-in data as a dataframe called nc
#nc<- read.delim("./ebd_northern_cardinal/nc_data.txt", header = TRUE, sep = "\t", dec = ".", nrows=1000)

# put into one dataframe
# rbind() stands for row-bind, which attaches the two dataframes we made
# it stacks them so the columns are the same 
# and all of the rows of both are kept/added
#together<- rbind(bcc,nc)

# save to new csv file to make faster in future
# we use write.csv() to export the combined dataframe we made
#write.csv(together, file = "eBird_data.csv")
# now it can be sent and used in any file
```

This next code chunk reads in the smaller csv file we made for this tutorial. You should have copied that csv file from where you got this tutorial and put both in the same folder so R can find it. Run the code chunk (click the play button!) and see what happens.

```{r}
eBird.df<- read.csv("eBird_data.csv")
```

This code chunk has no output, but if you click on the "Environment" tab in the top-right panel, you see the dataframe listed under "Data." Click on it to see it in a new tab in this panel. 

You can scroll up-down and left-right to see all the data we have available to investigate You can also click the arrows on the header row to sort the dataframe by any column to see what's there. This kind of exploration can also be done using R functions. 

After reading in the data, we have to understand how the variables are categorized to be able to manipulate it in later code chunks. The commands “head() and tail()” allow us to tell r where to start and where to end looking for the data. In this case we want the whole data set so we enter the file name into both lines. Then we use “summary()”, which gives us the 5 number summary of each numerical variable within the data set, as well as total count for categorical variables. From the data set, we have used the functions “unique() and table()” to specify what specific variable we want to look at as well as a table counting the number of birds from each species. 

Click on each line of code one at a time in the next code chunk, then press command/control + enter/return to run each line separately. 

```{r}
# view the "top" of the dataframe
head(eBird.df)

# view the "bottom" of the dataframe
tail(eBird.df)

# summarize the dataframe
summary(eBird.df)

# check to make sure we have our two species included in the dataframe and only those two species... 
unique(eBird.df$SCIENTIFIC.NAME)

# check that the number of observations for each species is as we expect (1000 each)
table(eBird.df$SCIENTIFIC.NAME)
```

These lines of code are very important to understanding the structure of our data. In later sections you'll learn how to apply statistical analyses to some of these variables, so a strong understanding of the underlying structure of the dataset as a whole and each variable itself (i.e. is it numerical or categorical?) becomes very important. 

For example, notice how some numerical variables were read into R as character strings? We can fix that by "cleaning-up" the data. Run the next code chunk to remove non-numeric values and set the variable types to be numerical, then open the newly edited dataset again to see what happened.

```{r}
eBird.df <- eBird.df %>%
  filter(OBSERVATION.COUNT!="X") %>%
  mutate(bird.count = as.numeric(OBSERVATION.COUNT)) %>%
  mutate(birder.count = as.numeric(NUMBER.OBSERVERS))
```

We used the "pippette" function (%>%) to filter() out observations listed as X (in eBird this means the data was not added). We also "piped" the data through the mutate() function to add new variable columns with the variables we are interested in correctly read as numeric variables. Now we can use the dataset properly!

# Question 1

First we will show you functions to use to investigate and compare trends for the Black-capped Chickadee and Northern Cardinal. Are they usually spotted in a group or alone? Where does each of these species have the most observations?

We will use histograms to compare how big groups of each bird are when they are observed. To best-visualize these we will create a plot using the package ggplot. The package “ggplot()” allows us to make all kinds of different graphs based on the kind of data we have. 

In the line “geom_histogram()” we tell ggplot to generate a histogram and give it details like the bar color and bin size. We can also change the axis titles from their default names by using “ylab()” and “xlab()” which rename the axis to whatever you put within the quotations. Run the code chunk to see the graph it produces and read the code line-by-line to learn what specifies each part of the graph.

```{r}
# make side-by-side histograms to compare 
ggplot(eBird.df) + # specify dataframe
  aes(x=bird.count, # continuous data variable
      fill=SCIENTIFIC.NAME) + # color by species
  facet_wrap(~SCIENTIFIC.NAME) + # group bars by species
  geom_histogram(color="black", # black histogram bars
                 binwidth=5) + # width of histogram bars
  theme_cowplot() + # pretty layout
  ylab("Number of Observations") + # axis title
  xlab("Number of Birds") + # axis title
  guides(fill="none") # remove the legend
```

Using the histogram, we can see that both species have left-skewed and tri-modal distributions of bird counts. We can infer that birds are usually either sighted alone or in large groups... or perhaps there is just a trend in the integers people choose to estimate the number of birds in a group.

Now that we have an understanding of the distribution of the data, let's investigate whether there's a difference between the distributions of the size of Black-capped Chickadee groups versus the size of Northern Cardinal groups. 

Once again we will use ggplot to generate a graph, but we tell it to make a boxplot this time. As you learn and continue to code, the many abilities of ggplot will come to great use to make a variety of visualizations.

```{r}
# make a boxplot to compare 
ggplot(eBird.df) + # specify dataframe
  aes(SCIENTIFIC.NAME, # independent variable
      bird.count, # dependent variable
      fill = SCIENTIFIC.NAME) + # color boxes by species
  geom_boxplot() + # add boxes to the graph
  theme_cowplot() + # pretty layout
  ylab("Number of Birds in a Group") + 
  xlab("Species") + # axis title
  guides(fill="none") # remove the legend
```

As we can see, the boxplots are very similar for both birds. The median and range both look almost the same. 

However, no definitive conclusions can be drawn without statistics.

Our first step when using statistics tests is to check the distribution of the data. While we've already visualized the distribution using the histograms and boxplots above, the shapiro.test() gives us the probability that a dataset is normally distributed. Run the next code chunk to check this for each species.

```{r}
Pa<- eBird.df %>% # pipe Chickadee into new dataframe 
  filter(SCIENTIFIC.NAME=="Poecile atricapillus")
shapiro.test(Pa$bird.count) # test normality

Cc<- eBird.df %>% # pipe Cardinal into new dataframe
  filter(SCIENTIFIC.NAME=="Cardinalis cardinalis")
shapiro.test(Cc$bird.count) # test normality
```

Both Shapiro-Wilk normality tests have significant p-values (<0.05), so the probability is almost zero percent chance likely that these datasets are normally distributed.

Since they are not normally distributed, we cannot use a t-test to investigate whether there is a significant difference in the size of observed groups of birds depending on the species, because a t-test assumes a normal distribution of the data. Instead, we will use the Wilcoxon rank-sum test.

```{r}
# statistical test for non-normal data
wilcox.test(Pa$bird.count,Cc$bird.count)
```

The p-value is 0.08035, which is above the conventional cut-off of <0.05 to be significant, so we shall conclude that there is no significant difference in the size of the group of birds between these two species, at least not for the observations submitted to eBird that we analyzed.

We couldn't conclude anything about differences in grouping behavior, but we could also try to investigate the best locations to observe each of these species.

What states in the US have the most eBird records for these birds? To find out, we need to sort the data. The package “dplyr” allows us to filter and sort the data easily. Using the piping method, we filter for only cardinals, and only records in the US. We group the data by state, and for each state, we count the number of observations that have been submitted. We use arrange() to sort the number of observations per state in descending order, then we filter so that the final dataset only includes states with more than 35 submissions. We do this separately for each species, except that we allow for lower observations in states we select for the Black-capped Chickadee than for the Cardinal.

Notice how most of the code can essentially be copied and pasted, then edited to take in whatever data you're using. Keep this in mind going forward.

```{r}
cardinal.locations <- eBird.df %>%
  dplyr::filter(SCIENTIFIC.NAME==
                  "Cardinalis cardinalis") %>%
  dplyr::filter(COUNTRY==
                  "United States") %>%
  group_by(STATE) %>%
  summarise(num_observations= 
              length(bird.count)) %>% 
  arrange(desc(num_observations))  %>%
  dplyr::filter(num_observations > 35)

chickadee.locations <- eBird.df %>%
  dplyr::filter(SCIENTIFIC.NAME==
                  "Poecile atricapillus") %>%
  dplyr::filter(COUNTRY==
                  "United States") %>%
  group_by(STATE) %>%
  summarise(num_observations= 
              length(bird.count)) %>% 
  arrange(desc(num_observations))  %>%
  dplyr::filter(num_observations > 22)
```  

Now that the data is sorted, we can make bar charts for the states with the top 5 highest number of bird observations for each of these species.

Once again we are going to use ggplot, but this time we use the geom_col() function to tell it to make bar graphs. The first line refers to the ggplot package and the dataframe we are using. The aes() function takes in the x and y variables, in this case state and number of observations. Read the code comments to be sure what each piece adds to the graph.

```{r}
# make a graph to see the top birding locations for the Northern Cardinal
ggplot(cardinal.locations) + # specify dataframe
  aes(STATE, # independent variable
      num_observations, 
      fill= STATE) + # dependent variable
  geom_col() + # specify what kind of graph
  theme_cowplot() + # pretty layout
  ylab("Number of Observations for Cardinals") + # axis label
  xlab("State") # axis label

ggplot(chickadee.locations) + #data
  aes(STATE, num_observations) + # data
  geom_col() + theme_cowplot() + # boxes and pretty layout
  ylab("Number of Observations for Chickadees") + xlab("State")


```

I want to figure out how to put in order of greatest to lowest...

# Question 2

Now you can use the same funtions to investigate birders. Are birders usually alone or in a group? Where are there more groups of birders?

# Tips for getting unstuck

Sometimes R can be very tricky to work if you’re new to it, but there are many resources available. Google is a great place to start, just by typing in “how to I get ____ in R?” often will get moving in the right direction. There are many great resources besides Google like on RStudio’s website there are plenty of cheat sheets to reference. Each cheat sheet corresponds with a package so you can learn all about the important commands within that package. Also never try to code from scratch, use what you already coded and what others have also coded. Re-writing code takes a lot of time and effort, but if you take previously written code and fit it to your data, your life will be much easier. Happy coding!

